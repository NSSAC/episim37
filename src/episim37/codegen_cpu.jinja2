{# Codegen for CPU #}

{% macro enum_type(t) %}
{{ t.line }}
typedef {{ t.base_type }} {{ t.name }};
{% for const in t.consts %}
const {{ t.name }} {{ const }} = {{ loop.index0 }};
{% endfor %}
{% endmacro %}

{% macro config(c) %}
{{ c.line }}
{{ c.type }} {{ c.name }} = {{ c.default }};
{% endmacro %}

{% macro global_variable(v) %}
{{ v.line }}
{{ v.type }} {{ v.var }} = {{ v.init }};
{% endmacro %}

{% macro alloc_h5_dataset_body(type, dataset_name, h5_type, count) %}
uint64_t alloc_size = sizeof({{ type }}) * {{ count }};
{{ type }}* ret = static_cast<{{ type }}*>(std::malloc(alloc_size));
assert(ret != nullptr);

H5::DataSet dataset = file.openDataSet("{{ dataset_name }}");
H5::DataSpace dataspace = dataset.getSpace();
int ndims = dataspace.getSimpleExtentNdims();
std::vector<hsize_t> dims(ndims);
dataspace.getSimpleExtentDims(&dims[0]);
assert(dims.size() == 1);
assert(dims[0] == {{ count }});
dataset.read(ret, {{ h5_type }});

return ret;
{% endmacro %}

{% macro alloc_mem_body(type, count) %}
uint64_t alloc_size = sizeof({{ type }}) * {{ count }};
{{ type }}* ret = static_cast<{{ type }}*>(std::malloc(alloc_size));
assert(ret != nullptr);

std::fill(ret, ret + {{ count }}, 0);

return ret;
{% endmacro %}

{% macro node_table(t) %}
static
uint64_t get_num_nodes(H5::H5File &file) {
    uint64_t ret;
    const char *attr_name = "num_nodes";

    H5::Attribute attr = file.openAttribute(attr_name);
    attr.read(attr.getDataType(), &ret);
    return ret;
}

{% for f in t.fields %}
static
{{ f.type }}*
alloc_node_{{ f.name }}(uint64_t num_nodes, H5::H5File &file) {
    {% if f.is_static %}
    {{ alloc_h5_dataset_body(f.type, f.dataset_name, f.h5_type, 'num_nodes') }}
    {% else %}
    {{ alloc_mem_body(f.type, 'num_nodes') }}
    {% endif %}
}

{% endfor %}

struct node_table {
    {% for f in t.fields %}
    {{ f.type }}* {{ f.name }};
    {% endfor %}

    uint64_t num_nodes;

    node_table(H5::H5File &file):
    {% for f in t.fields %}
    {{ f.name }}{nullptr},
    {% endfor %}
    num_nodes{0} {
        uint64_t n_nodes = get_num_nodes(file);
        {% for f in t.fields %}
        {{ f.name }} = alloc_node_{{ f.name }}(n_nodes, file);
        {% endfor %}
        num_nodes = n_nodes;
    }

    node_table() = delete;                              // default constructor
    node_table(const node_table &) = delete;            // copy constructor
    node_table(node_table &&) = delete;                 // move constructor
    node_table &operator=(const node_table &) = delete; // copy assignment
    node_table &operator=(node_table &&) = delete;      // move assignment

    ~node_table() {
    {% for f in t.fields %}
    std::free({{ f.name }});
    {% endfor %}

    {% for f in t.fields %}
    {{ f.name }} = nullptr;
    {% endfor %}
    num_nodes = 0;
  }
} ;

struct node {
    node_table *n;
    node_index_t i;

    node(node_table *nn, node_index_t ii):
    n{nn}, i{ii} {}
};
{% endmacro %}

{% macro edge_table(t) %}
static
uint64_t get_num_edges(H5::H5File &file) {
  uint64_t ret;
  const char *attr_name = "num_edges";

  H5::Attribute attr = file.openAttribute(attr_name);
  attr.read(attr.getDataType(), &ret);
  return ret;
}

{% for f in t.fields %}
static
{{ f.type }}* alloc_edge_{{ f.name }}(uint64_t num_edges, H5::H5File &file) {
    {% if f.is_static %}
    {{ alloc_h5_dataset_body(f.type, f.dataset_name, f.h5_type, 'num_edges') }}
    {% else %}
    {{ alloc_mem_body(f.type, 'num_edges') }}
    {% endif %}
}

{% endfor %}

struct edge_table {
    {% for f in t.fields %}
    {{ f.type }}* {{ f.name }};
    {% endfor %}

    uint64_t num_edges;

    edge_table(H5::H5File &file):
    {% for f in t.fields %}
    {{ f.name }}{nullptr},
    {% endfor %}
    num_edges{0} {
        uint64_t n_edges = get_num_edges(file);
        {% for f in t.fields %}
        {{ f.name }} = alloc_edge_{{ f.name }}(n_edges, file);
        {% endfor %}
        num_edges = n_edges;
    }

    edge_table() = delete;                              // default constructor
    edge_table(const edge_table &) = delete;            // copy constructor
    edge_table(edge_table &&) = delete;                 // move constructor
    edge_table &operator=(const edge_table &) = delete; // copy assignment
    edge_table &operator=(edge_table &&) = delete;      // move assignment

    ~edge_table() {
    {% for f in t.fields %}
    std::free({{ f.name }});
    {% endfor %}

    {% for f in t.fields %}
    {{ f.name }} = nullptr;
    {% endfor %}
    num_edges = 0;
  }
} ;

struct edge {
    edge_table *e;
    node_table *n;
    edge_index_t i;

    edge(edge_table *ee, node_table *nn, edge_index_t ii):
    e{ee}, n{nn}, i{ii} {}
};
{% endmacro %}

{% macro adj_csr(a) %}
static
{{ a.edge_idx_type }}* alloc_adj_csr_data(uint64_t num_edges, H5::H5File &file) {
{{ alloc_h5_dataset_body(a.edge_idx_type, a.data_dataset_name, a.edge_idx_h5_type, 'num_edges') }}
}

static
{{ a.node_idx_type }}* alloc_adj_csr_indices(uint64_t num_nodes, H5::H5File &file) {
{{ alloc_h5_dataset_body(a.node_idx_type, a.indices_dataset_name, a.node_idx_h5_type, 'num_nodes') }}
}

static
{{ a.node_idx_type }}* alloc_adj_csr_indptr(uint64_t num_nodes, H5::H5File &file) {
{{ alloc_h5_dataset_body(a.node_idx_type, a.indptr_dataset_name, a.node_idx_h5_type, 'num_nodes') }}
}

struct adj_csr {
    {{ a.edge_idx_type }}* data;
    {{ a.node_idx_type }}* indices;
    {{ a.node_idx_type }}* indptr;

    uint64_t num_nodes;
    uint64_t num_edges;

    adj_csr(H5::H5File &file):
    data{nullptr},
    indices{nullptr},
    indptr{nullptr},
    num_nodes{0},
    num_edges{0} {
        uint64_t n_nodes = get_num_nodes(file);
        uint64_t n_edges = get_num_edges(file);
        
        data = alloc_adj_csr_data(num_edges, file);
        indices = alloc_adj_csr_indices(num_nodes, file);
        indptr = alloc_adj_csr_indptr(num_nodes, file);

        num_nodes = n_nodes;
        num_edges = n_edges;
    }

    adj_csr() = delete;                           // default constructor
    adj_csr(const adj_csr &) = delete;            // copy constructor
    adj_csr(adj_csr &&) = delete;                 // move constructor
    adj_csr &operator=(const adj_csr &) = delete; // copy assignment
    adj_csr &operator=(adj_csr &&) = delete;      // move assignment

    ~adj_csr() {
    std::free(data);
    std::free(indices);
    std::free(indptr);

    data = nullptr;
    indices = nullptr;
    indptr = nullptr;

    num_nodes = 0;
    num_edges = 0;
  }
} ;

{% endmacro %}

{% macro function_params(params) %}
{% for name, type in params %}{{ type }} {{ name }}{{ "," if not loop.last else ""}}{% endfor %}
{% endmacro %}

{% macro function_decl(f) %}
static {{ f.return_ }} {{ f.name}}({{ function_params(f.params) }});
{% endmacro %}

{% macro function_def(f) %}
{{ f.line }}
static {{ f.return_ }} {{ f.name}}({{ function_params(f.params) }}) {
{% for name, type in f.variables %}
{{ type }} {{ name }};
{% endfor %}

{{ f.body }}
}
{% endmacro %}

{% macro simulator_cpp(s) %}
#include <cinttypes>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <H5Cpp.h>

typedef {{ s.node_idx_type }} node_index_t;
typedef {{ s.edge_idx_type }} edge_index_t;

{% for t in s.enums %}
{{ enum_type(t) }}
{% endfor %}

{% for c in s.configs %}
{{ config(c) }}
{% endfor %}

{% for v in s.variables %}
{{ global_variable(v) }}
{% endfor %}

{{ node_table(s.node_table) }}

{{ edge_table(s.edge_table) }}

{{ adj_csr(s.adj_csr) }}

{% for f in s.functions %}
{{ function_decl(f) }}
{% endfor %}

{% for f in s.functions %}
{{ function_def(f) }}
{% endfor %}

int main() {
    return 0;
}
{% endmacro %}


{% macro cmake_lists(s) %}
cmake_minimum_required(VERSION 3.27)

project({{s.module}} VERSION 0.0.1)

find_package(HDF5 REQUIRED COMPONENTS C CXX)

add_executable(simulator simulator.cpp)
target_link_libraries(simulator hdf5::hdf5_cpp hdf5::hdf5)
{% endmacro %}


