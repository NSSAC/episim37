{# Codegen for CPU #}

{% macro util_methods() %}
template <typename T>
T* alloc_mem(const size_type n) {
  const auto alloc_size = sizeof(T) * n;
  T* ret = static_cast<T*>(std::malloc(alloc_size));
  assert(ret != nullptr);

  #pragma omp parallel for
  for (size_type i = 0; i < n; i++) {
    ret[i] = 0;
  }

  return ret;
}

template <typename T>
void free_mem(T **p) {
  if (p == nullptr || *p == nullptr) {
    return;
  }
  std::free(*p);
  *p = nullptr;
}

template <typename T>
T get_attribute(const H5::H5File &file, const char* attr_name) {
    T ret;

    H5::Attribute attr = file.openAttribute(attr_name);
    attr.read(attr.getDataType(), &ret);
    attr.close();

    return ret;
}

template <typename T>
void read_dataset(
        const H5::H5File &file,
        const char* dataset_name,
        const H5::PredType& h5_type,
        const size_type count,
        T *const out) {
    H5::DataSet dataset = file.openDataSet(dataset_name);

    // Ensure datatype is correct
    H5::DataType dataset_type = dataset.getDataType();
    assert(dataset_type == h5_type);

    // Ensure count is correct
    H5::DataSpace dataspace = dataset.getSpace();
    const auto ndims = dataspace.getSimpleExtentNdims();
    std::vector<hsize_t> dims(ndims);
    dataspace.getSimpleExtentDims(&dims[0]);
    assert(dims.size() == 1);
    assert(dims[0] == count);

    dataset.read(out, h5_type);

    dataspace.close();
    dataset_type.close();
    dataset.close();
}
{% endmacro %}

{% macro enum_type(t) %}
{{ t.line }}
typedef {{ t.base_type }} {{ t.name }};
{% for const in t.consts %}
const {{ t.name }} {{ const }} = {{ loop.index0 }};
{% endfor %}
{% endmacro %}

{% macro config(c) %}
{{ c.line }}
{{ c.type }} {{ c.name }} = {{ c.default }};
{% endmacro %}

{% macro global_variable(v) %}
{{ v.line }}
{{ v.type }} {{ v.var }} = {{ v.init }};
{% endmacro %}

{% macro in_inc_csr(a) %}
struct in_inc_csr {
    {{ a.indptr.type }}* indptr;

    in_inc_csr(const H5::H5File &file):
    indptr{nullptr} {
        indptr = alloc_mem<{{ a.indptr.type }}>(NUM_NODES + 1);
        read_dataset(file, "{{ a.indptr.dataset_name }}", {{ a.indptr.h5_type}}, NUM_NODES + 1, indptr);
    }

    in_inc_csr() = delete;                              // default constructor
    in_inc_csr(const in_inc_csr &) = delete;            // copy constructor
    in_inc_csr(in_inc_csr &&) = delete;                 // move constructor
    in_inc_csr &operator=(const in_inc_csr &) = delete; // copy assignment
    in_inc_csr &operator=(in_inc_csr &&) = delete;      // move assignment

    ~in_inc_csr() {
        free_mem(&indptr);
    }
} ;
{% endmacro %}

{% macro thread_node_range() %}
struct thread_node_range {
  size_type* ptr;

  thread_node_range():
  ptr{nullptr} {
    ptr = alloc_mem<size_type>(NUM_THREADS + 1);

    edge_index_type *cum_in_neighbors = alloc_mem<edge_index_type>(NUM_NODES);
    size_type total_load = 0;
    for (size_type i = 0; i < NUM_NODES; i++) {
        total_load += IN_INC_CSR->indptr[i+1] - IN_INC_CSR->indptr[i];
        cum_in_neighbors[i] = total_load;
    }

    auto thread_load = total_load / NUM_THREADS;
    thread_load += (total_load % NUM_THREADS != 0);
    ptr[0] = 0;

    #pragma omp parallel
    {
	const auto thread_idx = omp_get_thread_num();
	auto needle = thread_load * (thread_idx + 1);
	if (needle > total_load) {
	    needle = total_load;
	}

	auto end = std::upper_bound(cum_in_neighbors, cum_in_neighbors + NUM_NODES, needle);
	ptr[thread_idx + 1] = end - cum_in_neighbors;
    }

    assert(ptr[0] == 0);
    assert(ptr[NUM_THREADS] == NUM_NODES);
    for (size_type i = 0; i < NUM_THREADS; i++) {
        assert(ptr[i] <= ptr[i+1]);
    }

    free_mem(&cum_in_neighbors);
  }

  size_type start(size_type thread_idx) const { return ptr[thread_idx]; };
  size_type end(size_type thread_idx) const { return ptr[thread_idx + 1]; };

  ~thread_node_range() {
    free_mem(&ptr);
  }
};
{% endmacro %}

{% macro thread_edge_range() %}
struct thread_edge_range {
  size_type* ptr;

  thread_edge_range():
  ptr{nullptr} {
    ptr = alloc_mem<size_type>(NUM_THREADS + 1);

    auto thread_load = NUM_EDGES / NUM_THREADS;
    thread_load += (NUM_EDGES % NUM_THREADS != 0);

    ptr[0] = 0;
    #pragma omp parallel
    {
	const auto thread_idx = omp_get_thread_num();
	auto end = thread_load * (thread_idx + 1);
	if (end > NUM_EDGES) {
	    end = NUM_EDGES;
	}
	ptr[thread_idx +1] = end;
    }

    assert(ptr[0] == 0);
    assert(ptr[NUM_THREADS] == NUM_EDGES);
    for (size_type i = 0; i < NUM_THREADS; i++) {
        assert(ptr[i] <= ptr[i+1]);
    }

  }

  size_type start(size_type thread_idx) const { return ptr[thread_idx]; };
  size_type end(size_type thread_idx) const { return ptr[thread_idx + 1]; };

  ~thread_edge_range() {
    free_mem(&ptr);
  }
};
{% endmacro %}

{% macro node_table(t) %}
size_type get_num_nodes(const H5::H5File &file) {
    return get_attribute<size_type>(file, "num_nodes");
}

struct node_table {
    {% for f in t.fields %}
    {{ f.type }}* {{ f.name }};
    {% endfor %}

    node_table(const H5::H5File &file):
    {% set comma = joiner(",") %}
    {% for f in t.fields %}
    {{ comma() }}{{ f.name }}{nullptr}
    {% endfor %}
    {
        {% for f in t.fields %}
        {{ f.name }} = alloc_mem<{{ f.type }}>(NUM_NODES);
        {% endfor %}

        {% for f in t.fields %}
        {% if f.is_static %}
        read_dataset(file, "{{ f.dataset_name }}", {{ f.h5_type}}, NUM_NODES, {{ f.name }});
        {% endif %}
        {% endfor %}
    }

    node_table() = delete;                              // default constructor
    node_table(const node_table &) = delete;            // copy constructor
    node_table(node_table &&) = delete;                 // move constructor
    node_table &operator=(const node_table &) = delete; // copy assignment
    node_table &operator=(node_table &&) = delete;      // move assignment

    ~node_table() {
        {% for f in t.fields %}
        free_mem(&{{ f.name }});
        {% endfor %}
  }
} ;

struct node_type {
    node_table *n;
    node_index_type i;

    node_type(node_table *nn, node_index_type ii):
    n{nn}, i{ii} {}
};

struct nodeset {
    bool_type *p;
    size_type size;

    nodeset():
    p{nullptr}, size{0} {
        p = alloc_mem<bool_type>(NUM_NODES);
        size = 0;
    }

    ~nodeset() {
        free_mem(&p);
        size = 0;
    }
};
{% endmacro %}

{% macro edge_table(t) %}
size_type get_num_edges(const H5::H5File &file) {
    return get_attribute<size_type>(file, "num_edges");
}

struct edge_table {
    {% for f in t.fields %}
    {{ f.type }}* {{ f.name }};
    {% endfor %}
    {{ t.target_node_index.type }}* target_node_index;
    {{ t.source_node_index.type }}* source_node_index;

    edge_table(const H5::H5File &file):
    {% set comma = joiner(", ") %}
    {% for f in t.fields %}
    {{ comma() }}{{ f.name }}{nullptr}
    {% endfor %}
    {
        {% for f in t.fields %}
        {{ f.name }} = alloc_mem<{{ f.type }}>(NUM_EDGES);
        {% endfor %}
        target_node_index = alloc_mem<{{ t.target_node_index.type }}>(NUM_EDGES);
        source_node_index = alloc_mem<{{ t.source_node_index.type }}>(NUM_EDGES);

        {% for f in t.fields %}
        {% if f.is_static %}
        read_dataset(file, "{{ f.dataset_name }}", {{ f.h5_type}}, NUM_EDGES, {{ f.name }});
        {% endif %}
        {% endfor %}
        read_dataset(file, "{{ t.target_node_index.dataset_name }}", {{ t.target_node_index.h5_type}}, NUM_EDGES, target_node_index);
        read_dataset(file, "{{ t.source_node_index.dataset_name }}", {{ t.source_node_index.h5_type}}, NUM_EDGES, source_node_index);
    }

    edge_table() = delete;                              // default constructor
    edge_table(const edge_table &) = delete;            // copy constructor
    edge_table(edge_table &&) = delete;                 // move constructor
    edge_table &operator=(const edge_table &) = delete; // copy assignment
    edge_table &operator=(edge_table &&) = delete;      // move assignment

    ~edge_table() {
        {% for f in t.fields %}
        free_mem(&{{ f.name }});
        {% endfor %}
        free_mem(&target_node_index);
        free_mem(&source_node_index);
    }
} ;

struct edge_type {
    edge_table *e;
    node_table *n;
    edge_index_type i;

    edge_type(edge_table *ee, node_table *nn, edge_index_type ii):
    e{ee}, n{nn}, i{ii} {}
};

struct edgeset {
    bool_type *p;
    size_type size;

    edgeset():
    p{nullptr}, size{0} {
        p = alloc_mem<bool_type>(NUM_EDGES);
        size = 0;
    }

    ~edgeset() {
        free_mem(&p);
        size = 0;
    }
};
{% endmacro %}

{% macro contagion_output_type(o) %}
struct {{ o.name }} {
    node_index_type* transition_node_idx;
    {{ o.state_type }}* transition_state;
    size_type* num_transitions;

    node_index_type* transmission_node_idx;
    edge_index_type* transmission_source;
    {{ o.state_type }}* transmission_state;
    size_type* num_transmissions;

    {{ o.name }}():
    transition_node_idx{nullptr},
    transition_state{nullptr},
    num_transitions{nullptr},
    transmission_node_idx{nullptr},
    transmission_source{nullptr},
    transmission_state{nullptr},
    num_transmissions{nullptr} {
        transition_node_idx = alloc_mem<node_index_type>(NUM_NODES);
        transition_state = alloc_mem<{{ o.state_type }}>(NUM_NODES);
        num_transitions = alloc_mem<size_type>(NUM_THREADS);

        transmission_node_idx = alloc_mem<node_index_type>(NUM_NODES);
        transmission_source = alloc_mem<edge_index_type>(NUM_NODES);
        transmission_state = alloc_mem<{{ o.state_type }}>(NUM_NODES);
        num_transmissions = alloc_mem<size_type>(NUM_THREADS);
    }

    void reset_transitions(const size_type thread_idx) {
        num_transitions[thread_idx] = 0;
    }

    void add_transition(
            const size_type thread_idx,
            const size_type v_start,
            const size_type v,
            const {{ o.state_type }} state) {
        auto idx = v_start + num_transitions[thread_idx];
        transition_node_idx[idx] = v;
        transition_state[idx] = state;
        num_transitions[thread_idx]++;
    }

    void save_transitions(const int_type tick) {
        const auto bufsize = 4096;
        char dataset_name[bufsize];

        auto ret = std::snprintf(dataset_name, bufsize, "/transitions/%ld", tick);
        assert(ret >= 0);
        assert(ret <= bufsize);
        H5::Group group = OUTPUT_FILE->createGroup(dataset_name);
        group.close();

        for (size_type thread_idx = 0; thread_idx < NUM_THREADS; thread_idx++) {
            auto ret = std::snprintf(dataset_name, bufsize, "/transitions/%ld/%ld", tick, thread_idx);
            assert(ret >= 0);
            assert(ret <= bufsize);
            H5::Group group = OUTPUT_FILE->createGroup(dataset_name);
            group.close();

            hsize_t dims[1] = {num_transitions[thread_idx]};
            H5::DataSpace dataspace(1, dims);

            auto v_start = NODE_RANGE->start(thread_idx);

            {
                auto ret = std::snprintf(dataset_name, bufsize, "/transitions/%ld/%ld/node_index", tick, thread_idx);
                assert(ret >= 0);
                assert(ret <= bufsize);
                H5::DataSet dataset = OUTPUT_FILE->createDataSet(dataset_name, LOCAL_H5_TYPE_NODE_INDEX_TYPE, dataspace);

                auto data = &(transition_node_idx[v_start]);
                dataset.write(data, LOCAL_H5_TYPE_NODE_INDEX_TYPE);
                dataset.close();
            }

            {
                auto ret = std::snprintf(dataset_name, bufsize, "/transitions/%ld/%ld/state", tick, thread_idx);
                assert(ret >= 0);
                assert(ret <= bufsize);
                H5::DataSet dataset = OUTPUT_FILE->createDataSet(dataset_name, {{ o.state_h5_type }}, dataspace);

                auto data = &(transition_state[v_start]);
                dataset.write(data, {{ o.state_h5_type }});
                dataset.close();
            }

        }
    }

    void reset_transmissions(const size_type thread_idx) {
        num_transmissions[thread_idx] = 0;
    }

    void add_transmission(
            const size_type thread_idx,
            const size_type v_start,
            const size_type v,
            const size_type e,
            const {{ o.state_type }} state) {
        auto idx = v_start + num_transmissions[thread_idx];
        transmission_node_idx[idx] = v;
        transmission_source[idx] = e;
        transmission_state[idx] = state;
        num_transmissions[thread_idx]++;
    }

    void save_transmissions(const int_type tick) {
        const auto bufsize = 4096;
        char dataset_name[bufsize];

        auto ret = std::snprintf(dataset_name, bufsize, "/transmissions/%ld", tick);
        assert(ret >= 0);
        assert(ret <= bufsize);
        H5::Group group = OUTPUT_FILE->createGroup(dataset_name);
        group.close();

        for (size_type thread_idx = 0; thread_idx < NUM_THREADS; thread_idx++) {
            auto ret = std::snprintf(dataset_name, bufsize, "/transmissions/%ld/%ld", tick, thread_idx);
            assert(ret >= 0);
            assert(ret <= bufsize);
            H5::Group group = OUTPUT_FILE->createGroup(dataset_name);
            group.close();

            hsize_t dims[1] = {num_transmissions[thread_idx]};
            H5::DataSpace dataspace(1, dims);

            auto v_start = NODE_RANGE->start(thread_idx);

            {
                auto ret = std::snprintf(dataset_name, bufsize, "/transmissions/%ld/%ld/node_index", tick, thread_idx);
                assert(ret >= 0);
                assert(ret <= bufsize);
                H5::DataSet dataset = OUTPUT_FILE->createDataSet(dataset_name, LOCAL_H5_TYPE_NODE_INDEX_TYPE, dataspace);

                auto data = &(transmission_node_idx[v_start]);
                dataset.write(data, LOCAL_H5_TYPE_NODE_INDEX_TYPE);
                dataset.close();
            }

            {
                auto ret = std::snprintf(dataset_name, bufsize, "/transmissions/%ld/%ld/source_edge_index", tick, thread_idx);
                assert(ret >= 0);
                assert(ret <= bufsize);
                H5::DataSet dataset = OUTPUT_FILE->createDataSet(dataset_name, LOCAL_H5_TYPE_EDGE_INDEX_TYPE, dataspace);

                auto data = &(transmission_source[v_start]);
                dataset.write(data, LOCAL_H5_TYPE_EDGE_INDEX_TYPE);
                dataset.close();
            }

            {
                auto ret = std::snprintf(dataset_name, bufsize, "/transmissions/%ld/%ld/state", tick, thread_idx);
                assert(ret >= 0);
                assert(ret <= bufsize);
                H5::DataSet dataset = OUTPUT_FILE->createDataSet(dataset_name, {{ o.state_h5_type }}, dataspace);

                auto data = &(transmission_state[v_start]);
                dataset.write(data, {{ o.state_h5_type }});
                dataset.close();
            }

        }
    }

    ~{{ o.name }}() {
        free_mem(&transition_node_idx);
        free_mem(&transition_state);
        free_mem(&num_transitions);

        free_mem(&transmission_node_idx);
        free_mem(&transmission_source);
        free_mem(&transmission_state);
        free_mem(&num_transmissions);
    }
};
{% endmacro %}

{% macro contagion_output_var(o) %}
{{ o.name }}* {{ o.gvar_name }} = nullptr;
{% endmacro %}

{% macro rnd_state() %}
struct rnd_state {
    rnd_state_type* rnd;

    rnd_state():
    rnd{nullptr} {
        rnd = static_cast<rnd_state_type*>(std::malloc(sizeof(rnd_state_type) * NUM_THREADS));

        std::random_device rd;
        auto const now = std::chrono::system_clock::now();
        auto const now_t = std::chrono::system_clock::to_time_t(now);
        #pragma omp parallel
        {
            const auto thread_idx = omp_get_thread_num();

            rnd_state_type gen(rd());
            gen.seed(now_t + thread_idx);
            rnd[thread_idx] = gen;
        }
    }

    ~rnd_state() {
        std::free(rnd);
        rnd = nullptr;
    }
};
{% endmacro %}

{% macro constant_dist(d) %}
float_type {{ d.name }}(rnd_state_type *const rnd) {
    return {{ d.v }} ;
}
{% endmacro %}

{% macro discrete_dist(d) %}
{% set comma = joiner(", ") %}
const float_type {{ d.name }}_PROBS[] = { {% for p in d.probs %}{{ comma() }}{{ p }}{% endfor %} };
{% set comma = joiner(", ") %}
const size_type {{ d.name }}_ALIAS[] = { {% for a in d.alias %}{{ comma() }}{{ a }}{% endfor %} };
{% set comma = joiner(", ") %}
const float_type {{ d.name }}_VS[] = { {% for v in d.vs %}{{ comma() }}{{ v }}{% endfor %} };
std::uniform_int_distribution<size_type> {{ d.name }}_INDEX_DIST { 0, {{ d.probs|length - 1 }} };

float_type {{ d.name }}(rnd_state_type *const rnd) {
    auto i = {{ d.name }}_INDEX_DIST(*rnd);
    const auto u = uniform01(*rnd);

    if ({{ d.name }}_PROBS[i] < u) {
        i = {{ d.name }}_ALIAS[i];
    }

    return {{ d.name }}_VS[i];
}
{% endmacro %}

{% macro normal_dist(d) %}
std::normal_distribution<float_type> {{ d.name }}_NORMAL_DIST { {{ d.mean }}, {{ d.std }} };

float_type {{ d.name }}(rnd_state_type *const rnd) {
    auto ret = {{ d.name }}_NORMAL_DIST(*rnd);
    if (ret > {{ d.max }}) {
        ret = {{ d.max }};
    }
    if (ret < {{ d.min }}) {
        ret = {{ d.min }};
    }
    return ret;
}
{% endmacro %}

{% macro uniform_dist(d) %}
std::uniform_real_distribution<float_type> {{ d.name }}_UNIFORM_DIST { {{ d.low }}, {{ d.high }} };

float_type {{ d.name }}(rnd_state_type *const rnd) {
    return {{ d.name }}_UNIFORM_DIST(*rnd);
}
{% endmacro %}

{% macro multi_exit_transition_vars(t) %}
{% set comma = joiner(", ") %}
const float_type {{ t.name }}_PROBS[] = { {% for p in t.probs %}{{ comma() }}{{ p }}{% endfor %} };
{% set comma = joiner(", ") %}
const size_type {{ t.name }}_ALIAS[] = { {% for a in t.alias %}{{ comma() }}{{ a }}{% endfor %} };
std::uniform_int_distribution<size_type> {{ t.name }}_INDEX_DIST { 0, {{ t.probs|length - 1 }} };
{% endmacro %}

{% macro do_transition(dt) %}
{% for t in dt.multi %}
{{ multi_exit_transition_vars(t) }}
{% endfor %}

void {{ dt.name }}_node(
        const size_type v,
        rnd_state_type *const rnd,
        const float_type elapsed,
        const size_type thread_idx,
        const size_type v_start) {
    auto state = NODE_TABLE->{{ dt.state }}[v];
    auto next_state = NODE_TABLE->{{ dt.next_state }}[v];
    auto dwell_time = NODE_TABLE->{{ dt.dwell_time }}[v];

    // Nothing has changed
    if (state == next_state) {
        return;
    }

    dwell_time -= elapsed;
    if (dwell_time > 0.0) {
        NODE_TABLE->{{ dt.dwell_time }}[v] = dwell_time;
        return;
    }

    state = next_state;
    dwell_time = 0.0;
    {{ dt.output_gvar }}->add_transition(thread_idx, v_start, v, state);

    switch (state) {
    {% for t in dt.single %}
    case {{ t.entry }}:
        next_state = {{ t.exit }};
        dwell_time = {{ t.dwell_dist }}(rnd);
        break;
    {% endfor %}
    {% for t in dt.multi %}
    case {{ t.entry }}:
        {
            auto i = {{ t.name }}_INDEX_DIST(*rnd);
            const auto u = uniform01(*rnd);

            if ({{ t.name }}_PROBS[i] < u) {
                i = {{ t.name }}_ALIAS[i];
            }

            switch (i) {
            {% for j in range(t.probs|length) %}
            case {{ j }}:
                next_state = {{ t.exits[j] }};
                dwell_time = {{ t.dwell_dists[j] }}(rnd);
                break;
            {% endfor %}
            }
        }
        break;
    {% endfor %}
    }

    NODE_TABLE->{{ dt.state }}[v] = state;
    NODE_TABLE->{{ dt.next_state }}[v] = next_state;
    NODE_TABLE->{{ dt.dwell_time }}[v] = dwell_time;
}

void {{ dt.name }}(const int_type tick, const float_type elapsed) {
    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);

        {{ dt.output_gvar }}->reset_transitions(thread_idx);

        const auto v_start = NODE_RANGE->start(thread_idx);
        const auto v_end = NODE_RANGE->end(thread_idx);
        for (size_type v = v_start; v < v_end; v++) {
            {{ dt.name }}_node(v, rnd, elapsed, thread_idx, v_start);
        }
    }

    {{ dt.output_gvar }}->save_transitions(tick);
}

{% endmacro %}

{% macro do_transmission(dt) %}
void {{ dt.name }}_update_tprob(const size_type e) {
    const auto v = EDGE_TABLE->target_node_index[e];
    const auto u = EDGE_TABLE->source_node_index[e];

    float_type tprob = {{ dt.enabled }}(edge_type(EDGE_TABLE, NODE_TABLE, e));
    tprob *= {{ dt.susceptibility }}(node_type(NODE_TABLE, v));
    tprob *= {{ dt.infectivity }}(node_type(NODE_TABLE, u));
    tprob *= {{ dt.transmissibility }}(edge_type(EDGE_TABLE, NODE_TABLE, e));
    if (tprob < 0.0) {
        tprob = 0.0;
    }
    if (tprob > 1.0) {
        tprob = 1.0;
    }

    EDGE_TABLE->{{ dt.tprob }}[e] = tprob;
}

void
{{ dt.name }}_transmit(
        const size_type v,
        rnd_state_type *const rnd,
        const size_type thread_idx,
        const size_type v_start) {
    const auto start = IN_INC_CSR->indptr[v];
    const auto end = IN_INC_CSR->indptr[v+1];

    float_type tprob_sum = 0.0;
    float_type tprob = 1.0;
    for (size_type e = start; e < end; e++) {
        auto p = EDGE_TABLE->{{ dt.tprob }}[e];
        tprob_sum += p;
        tprob *= (1.0 - p);
    }
    tprob = 1.0 - tprob;

    auto prob = uniform01(*rnd);
    if (prob >= tprob) {
        return;
    }

    auto esel = NUM_EDGES;
    auto esel_weight = uniform01(*rnd) * tprob_sum;
    tprob_sum = 0.0;
    for (size_type e = start; e < end; e++) {
        auto p = EDGE_TABLE->{{ dt.tprob }}[e];
        tprob_sum += p;
        if (tprob_sum >= esel_weight) {
            esel = e;
            break;
        }
    }
    assert(esel != NUM_EDGES);

    const auto u = EDGE_TABLE->source_node_index[esel];
    const auto t_state = NODE_TABLE->{{ dt.state }}[v];
    const auto u_state = NODE_TABLE->{{ dt.state }}[u];

    switch (t_state) {
    {% for entry, cxs in dt.transms %}
    case {{ entry }}:
            switch (u_state) {
            {% for contact, exit in cxs %}
            case {{ contact }}:
                NODE_TABLE->{{ dt.state }}[v] = {{ exit }};
                {{ dt.output_gvar }}->add_transmission(thread_idx, v_start, v, esel, {{ exit }});
                break;
            {% endfor %}
            }
        break;
    {% endfor %}
    }
}

void
{{ dt.name }}(const int_type tick) {
    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);

        {{ dt.output_gvar }}->reset_transmissions(thread_idx);

        const auto e_start = EDGE_RANGE->start(thread_idx);
        const auto e_end = EDGE_RANGE->end(thread_idx);
        for (size_type e = e_start; e < e_end; e++) {
            {{ dt.name}}_update_tprob(e);
        }

        const auto v_start = NODE_RANGE->start(thread_idx);
        const auto v_end = NODE_RANGE->end(thread_idx);
        for (size_type v = v_start; v < v_end; v++) {
            {{ dt.name}}_transmit(v, rnd, thread_idx, v_start);
        }
    }

    {{ dt.output_gvar }}->save_transmissions(tick);
}
{% endmacro %}

{% macro function_params(params) %}
{% set comma = joiner(", ") %}
{% for name, type in params %}{{ comma() }}{{ type }} {{ name }}{% endfor %}
{% endmacro %}

{% macro function_decl(f) %}
{{ f.return_ }} {{ f.name}}({{ function_params(f.params) }});
{% endmacro %}

{% macro function_def(f) %}
{{ f.line }}
{{ f.return_ }} {{ f.name}}({{ function_params(f.params) }}) {
{% for name, type in f.variables %}
    {{ type }} {{ name }};
{% endfor %}

{{ f.body }}
}
{% endmacro %}

{% macro simulator_cpp(s) %}
#include <cinttypes>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>
#include <omp.h>
#include <H5Cpp.h>

// ----------------------------------------------------------------------------
// Common types
// ----------------------------------------------------------------------------

{% for t in s.deferred_types %}
typedef {{ t.base_ctype }} {{ t.name }};
{% endfor %}

{% for t in s.deferred_types %}
const H5::PredType {{ t.h5_type }} = {{ t.base_h5_type }};
{% endfor %}

{{ util_methods() }}

// ----------------------------------------------------------------------------
// Enumerations
// ----------------------------------------------------------------------------

{% for t in s.enums %}
{{ enum_type(t) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Config variables
// ----------------------------------------------------------------------------

{% for c in s.configs %}
{{ config(c) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Global variables
// ----------------------------------------------------------------------------

{% for v in s.variables %}
{{ global_variable(v) }}
{% endfor %}

size_type NUM_THREADS = 0;
size_type NUM_NODES = 0;
size_type NUM_EDGES = 0;

// ----------------------------------------------------------------------------
// Incidence network (target_node_index, edge_index)
// ----------------------------------------------------------------------------

{{ in_inc_csr(s.in_inc_csr) }}

in_inc_csr* IN_INC_CSR = nullptr;

{{ thread_node_range() }}
{{ thread_edge_range() }}

thread_edge_range* EDGE_RANGE = nullptr;
thread_node_range* NODE_RANGE = nullptr;

// ----------------------------------------------------------------------------
// Node table
// ----------------------------------------------------------------------------

{{ node_table(s.node_table) }}

node_table *NODE_TABLE = nullptr;

// ----------------------------------------------------------------------------
// Edge table
// ----------------------------------------------------------------------------

{{ edge_table(s.edge_table) }}

edge_table* EDGE_TABLE = nullptr;

// ----------------------------------------------------------------------------
// Contagion output containers
// ----------------------------------------------------------------------------

H5::H5File* OUTPUT_FILE = nullptr;

{% for o in s.contagion_outputs %}
{{ contagion_output_type(o) }}
{% endfor %}

{% for o in s.contagion_outputs %}
{{ contagion_output_var(o) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Random number generator
// ----------------------------------------------------------------------------

typedef std::mt19937 rnd_state_type;

{{ rnd_state() }}

rnd_state* RND_STATE = nullptr;
std::uniform_real_distribution<float_type> uniform01 { 0.0, 1.0 };

// ----------------------------------------------------------------------------
// Constant distributions
// ----------------------------------------------------------------------------

{% for d in s.constant_dists %}
{{ constant_dist(d) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Discrete distributions
// ----------------------------------------------------------------------------

{% for d in s.discrete_dists %}
{{ discrete_dist(d) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Uniform distributions
// ----------------------------------------------------------------------------

{% for d in s.uniform_dists %}
{{ uniform_dist(d) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Normal distributions
// ----------------------------------------------------------------------------

{% for d in s.normal_dists %}
{{ normal_dist(d) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Function declarations
// ----------------------------------------------------------------------------

{% for f in s.functions %}
{{ function_decl(f) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Contagion transition functions
// ----------------------------------------------------------------------------

{% for dt in s.do_transitions %}
{{ do_transition(dt) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Contagion transmission functions
// ----------------------------------------------------------------------------

{% for dt in s.do_transmissions %}
{{ do_transmission(dt) }}
{% endfor %}

// ----------------------------------------------------------------------------
// Nodesets and edgesets
// ----------------------------------------------------------------------------

{% for name in s.nodesets %}
nodeset* {{ name }} = nullptr;
{% endfor %}

{% for name in s.edgesets %}
edgeset* {{ name }} = nullptr;
{% endfor %}

// ----------------------------------------------------------------------------
// Device functions
// ----------------------------------------------------------------------------

{% for f in s.select_using_node %}
void {{ f.name }}() {
    {{ f.set_name }}->size = 0;

    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);
        const auto v_start = NODE_RANGE->start(thread_idx);
        const auto v_end = NODE_RANGE->end(thread_idx);

        size_type size = 0;
        for (size_type v = v_start; v < v_end; v++) {
            const auto b = {{ f.function_name }}(node_type(NODE_TABLE, v));
            {{ f.set_name }}->p[v] = b;
            size += b;
        }

        #pragma omp atomic
        {{ f.set_name }}->size += size;
    }

    std::cout << "{{ f.name }} " << {{ f.set_name }}->size << std::endl;
}
{% endfor %}

{% for f in s.select_using_edge %}
void {{ f.name }}() {
    {{ f.set_name }}->size = 0;

    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);
        const auto e_start = EDGE_RANGE->start(thread_idx);
        const auto e_end = EDGE_RANGE->end(thread_idx);

        size_type size = 0;
        for (size_type e = e_start; e < e_end; v++) {
            const auto b = {{ f.function_name }}(edge_type(EDGE_TABLE, NODE_TABLE, e));
            {{ f.set_name }}->p[e] = b;
            size += b;
        }

        #pragma omp atomic
        {{ f.set_name }}->size += size;
    }

    std::cout << "{{ f.name }} " << {{ f.set_name }}->size << std::endl;
}
{% endfor %}

{% for f in s.select_approx_node %}
void {{ f.name }}() {
    {{ f.set_name }}->size = 0;
    const float_type prob = float_type({{ f.amount }}) / {{ f.parent_set_name }}->size;

    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);
        const auto v_start = NODE_RANGE->start(thread_idx);
        const auto v_end = NODE_RANGE->end(thread_idx);

        size_type size = 0;
        for (size_type v = v_start; v < v_end; v++) {
            {{ f.set_name }}->p[v] = 0;
            if ({{ f.parent_set_name }}->p[v]) {
                const auto p = uniform01(*rnd);
                if (p < prob) {
                    {{ f.set_name }}->p[v] = 1;
                    size += 1;
                }
            }
        }

        #pragma omp atomic
        {{ f.set_name }}->size += size;
    }

    std::cout << "{{ f.name }} " << {{ f.set_name }}->size << std::endl;
}
{% endfor %}

{% for f in s.select_approx_edge %}
void {{ f.name }}() {
    {{ f.set_name }}->size = 0;
    const float_type prob = float_type({{ f.amount }}) / {{ f.parent_set_name }}->size;

    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);
        const auto e_start = EDGE_RANGE->start(thread_idx);
        const auto e_end = EDGE_RANGE->end(thread_idx);

        size_type size = 0;
        for (size_type e = e_start; e < e_end; e++) {
            {{ f.set_name }}->p[e] = 0;
            if ({{ f.parent_set_name }}->p[e]) {
                const auto p = uniform01(*rnd);
                if (p < prob) {
                    {{ f.set_name }}->p[e] = 1;
                    size += 1;
                }
            }
        }

        #pragma omp atomic
        {{ f.set_name }}->size += size;
    }

    std::cout << "{{ f.name }} " << {{ f.set_name }}->size << std::endl;
}
{% endfor %}

{% for f in s.select_relative_node %}
void {{ f.name }}() {
    {{ f.set_name }}->size = 0;
    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);
        const auto v_start = NODE_RANGE->start(thread_idx);
        const auto v_end = NODE_RANGE->end(thread_idx);

        size_type size = 0;
        for (size_type v = v_start; v < v_end; v++) {
            {{ f.set_name }}->p[v] = 0;
            if ({{ f.parent_set_name }}->p[v]) {
                const auto p = uniform01(*rnd);
                if (p < {{ f.amount }}) {
                    {{ f.set_name }}->p[v] = 1;
                    size += 1;
                }
            }
        }

        #pragma omp atomic
        {{ f.set_name }}->size += size;
    }

    std::cout << "{{ f.name }} " << {{ f.set_name }}->size << std::endl;
}
{% endfor %}

{% for f in s.select_relative_edge %}
void {{ f.name }}() {
    {{ f.set_name }}->size = 0;

    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto rnd = &(RND_STATE->rnd[thread_idx]);
        const auto e_start = EDGE_RANGE->start(thread_idx);
        const auto e_end = EDGE_RANGE->end(thread_idx);

        size_type size = 0;
        for (size_type e = e_start; e < e_end; e++) {
            {{ f.set_name }}->p[e] = 0;
            if ({{ f.parent_set_name }}->p[e]) {
                const auto p = uniform01(*rnd);
                if (p < {{ f.amount }}) {
                    {{ f.set_name }}->p[e] = 1;
                    size += 1;
                }
            }
        }

        #pragma omp atomic
        {{ f.set_name }}->size += size;
    }

    std::cout << "{{ f.name }} " << {{ f.set_name }}->size << std::endl;
}
{% endfor %}

{% for f in s.foreach_node_statement %}
void {{ f.name }}() {
    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto v_start = NODE_RANGE->start(thread_idx);
        const auto v_end = NODE_RANGE->end(thread_idx);

        for (size_type v = v_start; v < v_end; v++) {
            if ({{ f.set_name }}->p[v]) {
               {{ f.function_name }}(node_type(NODE_TABLE, v));
            }
        }
    }
}
{% endfor %}

{% for f in s.foreach_edge_statement %}
void {{ f.name }}() {
    #pragma omp parallel
    {
        const auto thread_idx = omp_get_thread_num();
        const auto e_start = EDGE_RANGE->start(thread_idx);
        const auto e_end = EDGE_RANGE->end(thread_idx);

        for (size_type e = e_start; e < e_end; e++) {
            if ({{ f.set_name }}->p[e]) {
               {{ f.function_name }}(edge_type(EDGE_TABLE, NODE_TABLE, e));
            }
        }
    }
}
{% endfor %}

// ----------------------------------------------------------------------------
// Function definitions
// ----------------------------------------------------------------------------

{% for f in s.functions %}
{{ function_def(f) }}
{% endfor %}


// ----------------------------------------------------------------------------
// Main
// ----------------------------------------------------------------------------

int main() {
    const auto init_start{std::chrono::steady_clock::now()};
    NUM_THREADS = omp_get_max_threads();
    std::cout << "### num_threads: " << NUM_THREADS << std::endl;

    {% for c in s.configs %}
    {
        const char *p = std::getenv("{{ c.env_var }}");
        if (p) {
            {{ c.name }} = {{ c.from_str_fn }}(p);
        }
        std::cout << "### {{ c.print_name }} = " << std::to_string({{ c.name }}) << std::endl;
    }
    {% endfor %}

    const char *input_file_name = "input.h5";
    {
        const char *p = std::getenv("INPUT_FILE");
        if (p) {
            input_file_name = p;
        }
        std::cout << "### input_file = " << input_file_name << std::endl;
    }

    const char *output_file_name = "output.h5";
    {
        const char *p = std::getenv("OUTPUT_FILE");
        if (p) {
            output_file_name = p;
        }
        std::cout << "### output_file = " << output_file_name << std::endl;
    }

    H5::H5File input_file(input_file_name, H5F_ACC_RDONLY);

    NUM_NODES = get_num_nodes(input_file);
    std::cout << "### num_nodes: " << NUM_NODES << std::endl;

    NUM_EDGES = get_num_edges(input_file);
    std::cout << "### num_edges: " << NUM_EDGES << std::endl;

    in_inc_csr csr(input_file);
    IN_INC_CSR = &csr;

    thread_edge_range edge_range;
    EDGE_RANGE = &edge_range;

    thread_node_range node_range;
    NODE_RANGE = &node_range;

    node_table nt(input_file);
    NODE_TABLE = &nt;

    edge_table et(input_file);
    EDGE_TABLE = &et;

    input_file.close();

    H5::H5File output_file(output_file_name, H5F_ACC_TRUNC);
    OUTPUT_FILE = &output_file;

    {
        H5::Group group = OUTPUT_FILE->createGroup("/transitions");
        group.close();
    }

    {
        H5::Group group = OUTPUT_FILE->createGroup("/transmissions");
        group.close();
    }

    {% for o in s.contagion_outputs %}
    {{ o.name }} {{ o.gvar_name | lower }};
    {{ o.gvar_name }} = &{{ o.gvar_name | lower }};
    {% endfor %}

    rnd_state rnd;
    RND_STATE = &rnd;

    {% for name in s.nodesets %}
    nodeset {{ name }}_local;
    {{ name }} = &{{ name }}_local;

    {% endfor %}

    {% for name in s.edgesets %}
    edgeset {{ name }}_local;
    {{ name }} = &{{ name }}_local;

    {% endfor %}

    const auto init_end{std::chrono::steady_clock::now()};
    const std::chrono::duration<double> init_seconds{init_end - init_start};
    std::cout << "### setup time (s): " << init_seconds.count() << std::endl;

    const auto main_start{std::chrono::steady_clock::now()};
    do_main();
    const auto main_end{std::chrono::steady_clock::now()};
    const std::chrono::duration<double> main_seconds{main_end - main_start};
    std::cout << "### main time (s): " << main_seconds.count() << std::endl;

    output_file.close();
    OUTPUT_FILE = nullptr;

    return 0;
}
{% endmacro %}

{% macro cmake_lists(s) %}
cmake_minimum_required(VERSION 3.27)

project({{ s.module }} VERSION 0.0.1)

find_package(HDF5 REQUIRED COMPONENTS C CXX)
find_package(OpenMP REQUIRED COMPONENTS C CXX)

add_executable(simulator simulator.cpp)
target_link_libraries(simulator hdf5::hdf5 hdf5::hdf5_cpp OpenMP::OpenMP_CXX)
target_compile_features(simulator PRIVATE cxx_std_17)
{% endmacro %}


